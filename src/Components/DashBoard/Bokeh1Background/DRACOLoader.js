/**
 * Bundled by jsDelivr using Rollup v2.79.1 and Terser v5.19.2.
 * Original file: /npm/three@0.160.0/examples/jsm/loaders/DRACOLoader.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import { Loader as e, FileLoader as t, SRGBColorSpace as r, LinearSRGBColorSpace as o, BufferGeometry as s, BufferAttribute as n, Color as i } from "./three.js"; const a = new WeakMap; class c extends e { constructor(e) { super(e), this.decoderPath = "", this.decoderConfig = {}, this.decoderBinary = null, this.decoderPending = null, this.workerLimit = 4, this.workerPool = [], this.workerNextTaskID = 1, this.workerSourceURL = "", this.defaultAttributeIDs = { position: "POSITION", normal: "NORMAL", color: "COLOR", uv: "TEX_COORD" }, this.defaultAttributeTypes = { position: "Float32Array", normal: "Float32Array", color: "Float32Array", uv: "Float32Array" } } setDecoderPath(e) { return this.decoderPath = e, this } setDecoderConfig(e) { return this.decoderConfig = e, this } setWorkerLimit(e) { return this.workerLimit = e, this } load(e, r, o, s) { const n = new t(this.manager); n.setPath(this.path), n.setResponseType("arraybuffer"), n.setRequestHeader(this.requestHeader), n.setWithCredentials(this.withCredentials), n.load(e, (e => { this.parse(e, r, s) }), o, s) } parse(e, t, o = (() => { })) { this.decodeDracoFile(e, t, null, null, r).catch(o) } decodeDracoFile(e, t, r, s, n = o, i = (() => { })) { const a = { attributeIDs: r || this.defaultAttributeIDs, attributeTypes: s || this.defaultAttributeTypes, useUniqueIDs: !!r, vertexColorSpace: n }; return this.decodeGeometry(e, a).then(t).catch(i) } decodeGeometry(e, t) { const r = JSON.stringify(t); if (a.has(e)) { const t = a.get(e); if (t.key === r) return t.promise; if (0 === e.byteLength) throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.") } let o; const s = this.workerNextTaskID++, n = e.byteLength, i = this._getWorker(s, n).then((r => (o = r, new Promise(((r, n) => { o._callbacks[s] = { resolve: r, reject: n }, o.postMessage({ type: "decode", id: s, taskConfig: t, buffer: e }, [e]) }))))).then((e => this._createGeometry(e.geometry))); return i.catch((() => !0)).then((() => { o && s && this._releaseTask(o, s) })), a.set(e, { key: r, promise: i }), i } _createGeometry(e) { const t = new s; e.index && t.setIndex(new n(e.index.array, 1)); for (let r = 0; r < e.attributes.length; r++) { const o = e.attributes[r], s = o.name, i = o.array, a = o.itemSize, c = new n(i, a); "color" === s && (this._assignVertexColorSpace(c, o.vertexColorSpace), c.normalized = i instanceof Float32Array == !1), t.setAttribute(s, c) } return t } _assignVertexColorSpace(e, t) { if (t !== r) return; const o = new i; for (let t = 0, r = e.count; t < r; t++)o.fromBufferAttribute(e, t).convertSRGBToLinear(), e.setXYZ(t, o.r, o.g, o.b) } _loadLibrary(e, r) { const o = new t(this.manager); return o.setPath(this.decoderPath), o.setResponseType(r), o.setWithCredentials(this.withCredentials), new Promise(((t, r) => { o.load(e, t, void 0, r) })) } preload() { return this._initDecoder(), this } _initDecoder() { if (this.decoderPending) return this.decoderPending; const e = "object" != typeof WebAssembly || "js" === this.decoderConfig.type, t = []; return e ? t.push(this._loadLibrary("draco_decoder.js", "text")) : (t.push(this._loadLibrary("draco_wasm_wrapper.js", "text")), t.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))), this.decoderPending = Promise.all(t).then((t => { const r = t[0]; e || (this.decoderConfig.wasmBinary = t[1]); const o = d.toString(), s = ["/* draco decoder */", r, "", "/* worker */", o.substring(o.indexOf("{") + 1, o.lastIndexOf("}"))].join("\n"); this.workerSourceURL = URL.createObjectURL(new Blob([s])) })), this.decoderPending } _getWorker(e, t) { return this._initDecoder().then((() => { if (this.workerPool.length < this.workerLimit) { const e = new Worker(this.workerSourceURL); e._callbacks = {}, e._taskCosts = {}, e._taskLoad = 0, e.postMessage({ type: "init", decoderConfig: this.decoderConfig }), e.onmessage = function (t) { const r = t.data; switch (r.type) { case "decode": e._callbacks[r.id].resolve(r); break; case "error": e._callbacks[r.id].reject(r); break; default: console.error('THREE.DRACOLoader: Unexpected message, "' + r.type + '"') } }, this.workerPool.push(e) } else this.workerPool.sort((function (e, t) { return e._taskLoad > t._taskLoad ? -1 : 1 })); const r = this.workerPool[this.workerPool.length - 1]; return r._taskCosts[e] = t, r._taskLoad += t, r })) } _releaseTask(e, t) { e._taskLoad -= e._taskCosts[t], delete e._callbacks[t], delete e._taskCosts[t] } debug() { console.log("Task load: ", this.workerPool.map((e => e._taskLoad))) } dispose() { for (let e = 0; e < this.workerPool.length; ++e)this.workerPool[e].terminate(); return this.workerPool.length = 0, "" !== this.workerSourceURL && URL.revokeObjectURL(this.workerSourceURL), this } } function d() { let e, t; function r(e, t, r, o, s, n) { const i = n.num_components(), a = r.num_points() * i, c = a * s.BYTES_PER_ELEMENT, d = function (e, t) { switch (t) { case Float32Array: return e.DT_FLOAT32; case Int8Array: return e.DT_INT8; case Int16Array: return e.DT_INT16; case Int32Array: return e.DT_INT32; case Uint8Array: return e.DT_UINT8; case Uint16Array: return e.DT_UINT16; case Uint32Array: return e.DT_UINT32 } }(e, s), l = e._malloc(c); t.GetAttributeDataArrayForAllPoints(r, n, d, c, l); const u = new s(e.HEAPF32.buffer, l, a).slice(); return e._free(l), { name: o, array: u, itemSize: i } } onmessage = function (o) { const s = o.data; switch (s.type) { case "init": e = s.decoderConfig, t = new Promise((function (t) { e.onModuleLoaded = function (e) { t({ draco: e }) }, DracoDecoderModule(e) })); break; case "decode": const o = s.buffer, n = s.taskConfig; t.then((e => { const t = e.draco, i = new t.Decoder; try { const e = function (e, t, o, s) { const n = s.attributeIDs, i = s.attributeTypes; let a, c; const d = t.GetEncodedGeometryType(o); if (d === e.TRIANGULAR_MESH) a = new e.Mesh, c = t.DecodeArrayToMesh(o, o.byteLength, a); else { if (d !== e.POINT_CLOUD) throw new Error("THREE.DRACOLoader: Unexpected geometry type."); a = new e.PointCloud, c = t.DecodeArrayToPointCloud(o, o.byteLength, a) } if (!c.ok() || 0 === a.ptr) throw new Error("THREE.DRACOLoader: Decoding failed: " + c.error_msg()); const l = { index: null, attributes: [] }; for (const o in n) { const c = self[i[o]]; let d, u; if (s.useUniqueIDs) u = n[o], d = t.GetAttributeByUniqueId(a, u); else { if (u = t.GetAttributeId(a, e[n[o]]), -1 === u) continue; d = t.GetAttribute(a, u) } const h = r(e, t, a, o, c, d); "color" === o && (h.vertexColorSpace = s.vertexColorSpace), l.attributes.push(h) } d === e.TRIANGULAR_MESH && (l.index = function (e, t, r) { const o = r.num_faces(), s = 3 * o, n = 4 * s, i = e._malloc(n); t.GetTrianglesUInt32Array(r, n, i); const a = new Uint32Array(e.HEAPF32.buffer, i, s).slice(); return e._free(i), { array: a, itemSize: 1 } }(e, t, a)); return e.destroy(a), l }(t, i, new Int8Array(o), n), a = e.attributes.map((e => e.array.buffer)); e.index && a.push(e.index.array.buffer), self.postMessage({ type: "decode", id: s.id, geometry: e }, a) } catch (e) { console.error(e), self.postMessage({ type: "error", id: s.id, error: e.message }) } finally { t.destroy(i) } })) } } } export { c as DRACOLoader }; export default null;
//# sourceMappingURL=/sm/ac47e60a741383fc0c407047d50af7e937f2bc773721080bf6b60a8cf38bc175.map