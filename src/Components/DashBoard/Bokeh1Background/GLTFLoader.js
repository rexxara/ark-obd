/**
 * Bundled by jsDelivr using Rollup v2.79.1 and Terser v5.19.2.
 * Original file: /npm/three@0.160.0/examples/jsm/loaders/GLTFLoader.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import { TrianglesDrawMode as e, TriangleFanDrawMode as t, TriangleStripDrawMode as s, Quaternion as n, Matrix4 as r, Loader as o, LoaderUtils as i, FileLoader as a, Color as c, LinearSRGBColorSpace as l, SpotLight as u, PointLight as h, DirectionalLight as d, MeshBasicMaterial as m, SRGBColorSpace as p, MeshPhysicalMaterial as f, Vector2 as A, Vector3 as g, InstancedMesh as T, InstancedBufferAttribute as x, Object3D as R, TextureLoader as E, ImageBitmapLoader as _, BufferAttribute as v, InterleavedBuffer as w, InterleavedBufferAttribute as y, LinearFilter as S, LinearMipmapLinearFilter as L, RepeatWrapping as I, PointsMaterial as M, Material as b, LineBasicMaterial as N, MeshStandardMaterial as O, DoubleSide as C, PropertyBinding as P, BufferGeometry as H, SkinnedMesh as F, Mesh as k, LineSegments as D, Line as U, LineLoop as B, Points as G, Group as j, PerspectiveCamera as K, MathUtils as X, OrthographicCamera as V, Skeleton as q, AnimationClip as z, Bone as Y, InterpolateLinear as W, ColorManagement as Q, NearestFilter as Z, NearestMipmapNearestFilter as J, LinearMipmapNearestFilter as $, NearestMipmapLinearFilter as ee, ClampToEdgeWrapping as te, MirroredRepeatWrapping as se, InterpolateDiscrete as ne, FrontSide as re, Texture as oe, VectorKeyframeTrack as ie, NumberKeyframeTrack as ae, QuaternionKeyframeTrack as ce, Box3 as le, Sphere as ue, Interpolant as he } from "./three.js"; function de(n, r) { if (r === e) return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."), n; if (r === t || r === s) { let e = n.getIndex(); if (null === e) { const t = [], s = n.getAttribute("position"); if (void 0 === s) return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), n; for (let e = 0; e < s.count; e++)t.push(e); n.setIndex(t), e = n.getIndex() } const s = e.count - 2, o = []; if (r === t) for (let t = 1; t <= s; t++)o.push(e.getX(0)), o.push(e.getX(t)), o.push(e.getX(t + 1)); else for (let t = 0; t < s; t++)t % 2 == 0 ? (o.push(e.getX(t)), o.push(e.getX(t + 1)), o.push(e.getX(t + 2))) : (o.push(e.getX(t + 2)), o.push(e.getX(t + 1)), o.push(e.getX(t))); o.length / 3 !== s && console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles."); const i = n.clone(); return i.setIndex(o), i.clearGroups(), i } return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", r), n } class me extends o { constructor(e) { super(e), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register((function (e) { return new xe(e) })), this.register((function (e) { return new Ie(e) })), this.register((function (e) { return new Me(e) })), this.register((function (e) { return new be(e) })), this.register((function (e) { return new Ee(e) })), this.register((function (e) { return new _e(e) })), this.register((function (e) { return new ve(e) })), this.register((function (e) { return new we(e) })), this.register((function (e) { return new Te(e) })), this.register((function (e) { return new ye(e) })), this.register((function (e) { return new Re(e) })), this.register((function (e) { return new Le(e) })), this.register((function (e) { return new Se(e) })), this.register((function (e) { return new Ae(e) })), this.register((function (e) { return new Ne(e) })), this.register((function (e) { return new Oe(e) })) } load(e, t, s, n) { const r = this; let o; if ("" !== this.resourcePath) o = this.resourcePath; else if ("" !== this.path) { const t = i.extractUrlBase(e); o = i.resolveURL(t, this.path) } else o = i.extractUrlBase(e); this.manager.itemStart(e); const c = function (t) { n ? n(t) : console.error(t), r.manager.itemError(e), r.manager.itemEnd(e) }, l = new a(this.manager); l.setPath(this.path), l.setResponseType("arraybuffer"), l.setRequestHeader(this.requestHeader), l.setWithCredentials(this.withCredentials), l.load(e, (function (s) { try { r.parse(s, o, (function (s) { t(s), r.manager.itemEnd(e) }), c) } catch (e) { c(e) } }), s, c) } setDRACOLoader(e) { return this.dracoLoader = e, this } setDDSLoader() { throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".') } setKTX2Loader(e) { return this.ktx2Loader = e, this } setMeshoptDecoder(e) { return this.meshoptDecoder = e, this } register(e) { return -1 === this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.push(e), this } unregister(e) { return -1 !== this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this } parse(e, t, s, n) { let r; const o = {}, i = {}, a = new TextDecoder; if ("string" == typeof e) r = JSON.parse(e); else if (e instanceof ArrayBuffer) { if (a.decode(new Uint8Array(e, 0, 4)) === Ce) { try { o[fe.KHR_BINARY_GLTF] = new Fe(e) } catch (e) { return void (n && n(e)) } r = JSON.parse(o[fe.KHR_BINARY_GLTF].content) } else r = JSON.parse(a.decode(e)) } else r = e; if (void 0 === r.asset || r.asset.version[0] < 2) return void (n && n(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."))); const c = new at(r, { path: t || this.resourcePath || "", crossOrigin: this.crossOrigin, requestHeader: this.requestHeader, manager: this.manager, ktx2Loader: this.ktx2Loader, meshoptDecoder: this.meshoptDecoder }); c.fileLoader.setRequestHeader(this.requestHeader); for (let e = 0; e < this.pluginCallbacks.length; e++) { const t = this.pluginCallbacks[e](c); t.name || console.error("THREE.GLTFLoader: Invalid plugin found: missing name"), i[t.name] = t, o[t.name] = !0 } if (r.extensionsUsed) for (let e = 0; e < r.extensionsUsed.length; ++e) { const t = r.extensionsUsed[e], s = r.extensionsRequired || []; switch (t) { case fe.KHR_MATERIALS_UNLIT: o[t] = new ge; break; case fe.KHR_DRACO_MESH_COMPRESSION: o[t] = new ke(r, this.dracoLoader); break; case fe.KHR_TEXTURE_TRANSFORM: o[t] = new De; break; case fe.KHR_MESH_QUANTIZATION: o[t] = new Ue; break; default: s.indexOf(t) >= 0 && void 0 === i[t] && console.warn('THREE.GLTFLoader: Unknown extension "' + t + '".') } } c.setExtensions(o), c.setPlugins(i), c.parse(s, n) } parseAsync(e, t) { const s = this; return new Promise((function (n, r) { s.parse(e, t, n, r) })) } } function pe() { let e = {}; return { get: function (t) { return e[t] }, add: function (t, s) { e[t] = s }, remove: function (t) { delete e[t] }, removeAll: function () { e = {} } } } const fe = { KHR_BINARY_GLTF: "KHR_binary_glTF", KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression", KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual", KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat", KHR_MATERIALS_IOR: "KHR_materials_ior", KHR_MATERIALS_SHEEN: "KHR_materials_sheen", KHR_MATERIALS_SPECULAR: "KHR_materials_specular", KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission", KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence", KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy", KHR_MATERIALS_UNLIT: "KHR_materials_unlit", KHR_MATERIALS_VOLUME: "KHR_materials_volume", KHR_TEXTURE_BASISU: "KHR_texture_basisu", KHR_TEXTURE_TRANSFORM: "KHR_texture_transform", KHR_MESH_QUANTIZATION: "KHR_mesh_quantization", KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength", EXT_MATERIALS_BUMP: "EXT_materials_bump", EXT_TEXTURE_WEBP: "EXT_texture_webp", EXT_TEXTURE_AVIF: "EXT_texture_avif", EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression", EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing" }; class Ae { constructor(e) { this.parser = e, this.name = fe.KHR_LIGHTS_PUNCTUAL, this.cache = { refs: {}, uses: {} } } _markDefs() { const e = this.parser, t = this.parser.json.nodes || []; for (let s = 0, n = t.length; s < n; s++) { const n = t[s]; n.extensions && n.extensions[this.name] && void 0 !== n.extensions[this.name].light && e._addNodeRef(this.cache, n.extensions[this.name].light) } } _loadLight(e) { const t = this.parser, s = "light:" + e; let n = t.cache.get(s); if (n) return n; const r = t.json, o = ((r.extensions && r.extensions[this.name] || {}).lights || [])[e]; let i; const a = new c(16777215); void 0 !== o.color && a.setRGB(o.color[0], o.color[1], o.color[2], l); const m = void 0 !== o.range ? o.range : 0; switch (o.type) { case "directional": i = new d(a), i.target.position.set(0, 0, -1), i.add(i.target); break; case "point": i = new h(a), i.distance = m; break; case "spot": i = new u(a), i.distance = m, o.spot = o.spot || {}, o.spot.innerConeAngle = void 0 !== o.spot.innerConeAngle ? o.spot.innerConeAngle : 0, o.spot.outerConeAngle = void 0 !== o.spot.outerConeAngle ? o.spot.outerConeAngle : Math.PI / 4, i.angle = o.spot.outerConeAngle, i.penumbra = 1 - o.spot.innerConeAngle / o.spot.outerConeAngle, i.target.position.set(0, 0, -1), i.add(i.target); break; default: throw new Error("THREE.GLTFLoader: Unexpected light type: " + o.type) }return i.position.set(0, 0, 0), i.decay = 2, tt(i, o), void 0 !== o.intensity && (i.intensity = o.intensity), i.name = t.createUniqueName(o.name || "light_" + e), n = Promise.resolve(i), t.cache.add(s, n), n } getDependency(e, t) { if ("light" === e) return this._loadLight(t) } createNodeAttachment(e) { const t = this, s = this.parser, n = s.json.nodes[e], r = (n.extensions && n.extensions[this.name] || {}).light; return void 0 === r ? null : this._loadLight(r).then((function (e) { return s._getNodeRef(t.cache, r, e) })) } } class ge { constructor() { this.name = fe.KHR_MATERIALS_UNLIT } getMaterialType() { return m } extendParams(e, t, s) { const n = []; e.color = new c(1, 1, 1), e.opacity = 1; const r = t.pbrMetallicRoughness; if (r) { if (Array.isArray(r.baseColorFactor)) { const t = r.baseColorFactor; e.color.setRGB(t[0], t[1], t[2], l), e.opacity = t[3] } void 0 !== r.baseColorTexture && n.push(s.assignTexture(e, "map", r.baseColorTexture, p)) } return Promise.all(n) } } class Te { constructor(e) { this.parser = e, this.name = fe.KHR_MATERIALS_EMISSIVE_STRENGTH } extendMaterialParams(e, t) { const s = this.parser.json.materials[e]; if (!s.extensions || !s.extensions[this.name]) return Promise.resolve(); const n = s.extensions[this.name].emissiveStrength; return void 0 !== n && (t.emissiveIntensity = n), Promise.resolve() } } class xe { constructor(e) { this.parser = e, this.name = fe.KHR_MATERIALS_CLEARCOAT } getMaterialType(e) { const t = this.parser.json.materials[e]; return t.extensions && t.extensions[this.name] ? f : null } extendMaterialParams(e, t) { const s = this.parser, n = s.json.materials[e]; if (!n.extensions || !n.extensions[this.name]) return Promise.resolve(); const r = [], o = n.extensions[this.name]; if (void 0 !== o.clearcoatFactor && (t.clearcoat = o.clearcoatFactor), void 0 !== o.clearcoatTexture && r.push(s.assignTexture(t, "clearcoatMap", o.clearcoatTexture)), void 0 !== o.clearcoatRoughnessFactor && (t.clearcoatRoughness = o.clearcoatRoughnessFactor), void 0 !== o.clearcoatRoughnessTexture && r.push(s.assignTexture(t, "clearcoatRoughnessMap", o.clearcoatRoughnessTexture)), void 0 !== o.clearcoatNormalTexture && (r.push(s.assignTexture(t, "clearcoatNormalMap", o.clearcoatNormalTexture)), void 0 !== o.clearcoatNormalTexture.scale)) { const e = o.clearcoatNormalTexture.scale; t.clearcoatNormalScale = new A(e, e) } return Promise.all(r) } } class Re { constructor(e) { this.parser = e, this.name = fe.KHR_MATERIALS_IRIDESCENCE } getMaterialType(e) { const t = this.parser.json.materials[e]; return t.extensions && t.extensions[this.name] ? f : null } extendMaterialParams(e, t) { const s = this.parser, n = s.json.materials[e]; if (!n.extensions || !n.extensions[this.name]) return Promise.resolve(); const r = [], o = n.extensions[this.name]; return void 0 !== o.iridescenceFactor && (t.iridescence = o.iridescenceFactor), void 0 !== o.iridescenceTexture && r.push(s.assignTexture(t, "iridescenceMap", o.iridescenceTexture)), void 0 !== o.iridescenceIor && (t.iridescenceIOR = o.iridescenceIor), void 0 === t.iridescenceThicknessRange && (t.iridescenceThicknessRange = [100, 400]), void 0 !== o.iridescenceThicknessMinimum && (t.iridescenceThicknessRange[0] = o.iridescenceThicknessMinimum), void 0 !== o.iridescenceThicknessMaximum && (t.iridescenceThicknessRange[1] = o.iridescenceThicknessMaximum), void 0 !== o.iridescenceThicknessTexture && r.push(s.assignTexture(t, "iridescenceThicknessMap", o.iridescenceThicknessTexture)), Promise.all(r) } } class Ee { constructor(e) { this.parser = e, this.name = fe.KHR_MATERIALS_SHEEN } getMaterialType(e) { const t = this.parser.json.materials[e]; return t.extensions && t.extensions[this.name] ? f : null } extendMaterialParams(e, t) { const s = this.parser, n = s.json.materials[e]; if (!n.extensions || !n.extensions[this.name]) return Promise.resolve(); const r = []; t.sheenColor = new c(0, 0, 0), t.sheenRoughness = 0, t.sheen = 1; const o = n.extensions[this.name]; if (void 0 !== o.sheenColorFactor) { const e = o.sheenColorFactor; t.sheenColor.setRGB(e[0], e[1], e[2], l) } return void 0 !== o.sheenRoughnessFactor && (t.sheenRoughness = o.sheenRoughnessFactor), void 0 !== o.sheenColorTexture && r.push(s.assignTexture(t, "sheenColorMap", o.sheenColorTexture, p)), void 0 !== o.sheenRoughnessTexture && r.push(s.assignTexture(t, "sheenRoughnessMap", o.sheenRoughnessTexture)), Promise.all(r) } } class _e { constructor(e) { this.parser = e, this.name = fe.KHR_MATERIALS_TRANSMISSION } getMaterialType(e) { const t = this.parser.json.materials[e]; return t.extensions && t.extensions[this.name] ? f : null } extendMaterialParams(e, t) { const s = this.parser, n = s.json.materials[e]; if (!n.extensions || !n.extensions[this.name]) return Promise.resolve(); const r = [], o = n.extensions[this.name]; return void 0 !== o.transmissionFactor && (t.transmission = o.transmissionFactor), void 0 !== o.transmissionTexture && r.push(s.assignTexture(t, "transmissionMap", o.transmissionTexture)), Promise.all(r) } } class ve { constructor(e) { this.parser = e, this.name = fe.KHR_MATERIALS_VOLUME } getMaterialType(e) { const t = this.parser.json.materials[e]; return t.extensions && t.extensions[this.name] ? f : null } extendMaterialParams(e, t) { const s = this.parser, n = s.json.materials[e]; if (!n.extensions || !n.extensions[this.name]) return Promise.resolve(); const r = [], o = n.extensions[this.name]; t.thickness = void 0 !== o.thicknessFactor ? o.thicknessFactor : 0, void 0 !== o.thicknessTexture && r.push(s.assignTexture(t, "thicknessMap", o.thicknessTexture)), t.attenuationDistance = o.attenuationDistance || 1 / 0; const i = o.attenuationColor || [1, 1, 1]; return t.attenuationColor = (new c).setRGB(i[0], i[1], i[2], l), Promise.all(r) } } class we { constructor(e) { this.parser = e, this.name = fe.KHR_MATERIALS_IOR } getMaterialType(e) { const t = this.parser.json.materials[e]; return t.extensions && t.extensions[this.name] ? f : null } extendMaterialParams(e, t) { const s = this.parser.json.materials[e]; if (!s.extensions || !s.extensions[this.name]) return Promise.resolve(); const n = s.extensions[this.name]; return t.ior = void 0 !== n.ior ? n.ior : 1.5, Promise.resolve() } } class ye { constructor(e) { this.parser = e, this.name = fe.KHR_MATERIALS_SPECULAR } getMaterialType(e) { const t = this.parser.json.materials[e]; return t.extensions && t.extensions[this.name] ? f : null } extendMaterialParams(e, t) { const s = this.parser, n = s.json.materials[e]; if (!n.extensions || !n.extensions[this.name]) return Promise.resolve(); const r = [], o = n.extensions[this.name]; t.specularIntensity = void 0 !== o.specularFactor ? o.specularFactor : 1, void 0 !== o.specularTexture && r.push(s.assignTexture(t, "specularIntensityMap", o.specularTexture)); const i = o.specularColorFactor || [1, 1, 1]; return t.specularColor = (new c).setRGB(i[0], i[1], i[2], l), void 0 !== o.specularColorTexture && r.push(s.assignTexture(t, "specularColorMap", o.specularColorTexture, p)), Promise.all(r) } } class Se { constructor(e) { this.parser = e, this.name = fe.EXT_MATERIALS_BUMP } getMaterialType(e) { const t = this.parser.json.materials[e]; return t.extensions && t.extensions[this.name] ? f : null } extendMaterialParams(e, t) { const s = this.parser, n = s.json.materials[e]; if (!n.extensions || !n.extensions[this.name]) return Promise.resolve(); const r = [], o = n.extensions[this.name]; return t.bumpScale = void 0 !== o.bumpFactor ? o.bumpFactor : 1, void 0 !== o.bumpTexture && r.push(s.assignTexture(t, "bumpMap", o.bumpTexture)), Promise.all(r) } } class Le { constructor(e) { this.parser = e, this.name = fe.KHR_MATERIALS_ANISOTROPY } getMaterialType(e) { const t = this.parser.json.materials[e]; return t.extensions && t.extensions[this.name] ? f : null } extendMaterialParams(e, t) { const s = this.parser, n = s.json.materials[e]; if (!n.extensions || !n.extensions[this.name]) return Promise.resolve(); const r = [], o = n.extensions[this.name]; return void 0 !== o.anisotropyStrength && (t.anisotropy = o.anisotropyStrength), void 0 !== o.anisotropyRotation && (t.anisotropyRotation = o.anisotropyRotation), void 0 !== o.anisotropyTexture && r.push(s.assignTexture(t, "anisotropyMap", o.anisotropyTexture)), Promise.all(r) } } class Ie { constructor(e) { this.parser = e, this.name = fe.KHR_TEXTURE_BASISU } loadTexture(e) { const t = this.parser, s = t.json, n = s.textures[e]; if (!n.extensions || !n.extensions[this.name]) return null; const r = n.extensions[this.name], o = t.options.ktx2Loader; if (!o) { if (s.extensionsRequired && s.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures"); return null } return t.loadTextureImage(e, r.source, o) } } class Me { constructor(e) { this.parser = e, this.name = fe.EXT_TEXTURE_WEBP, this.isSupported = null } loadTexture(e) { const t = this.name, s = this.parser, n = s.json, r = n.textures[e]; if (!r.extensions || !r.extensions[t]) return null; const o = r.extensions[t], i = n.images[o.source]; let a = s.textureLoader; if (i.uri) { const e = s.options.manager.getHandler(i.uri); null !== e && (a = e) } return this.detectSupport().then((function (r) { if (r) return s.loadTextureImage(e, o.source, a); if (n.extensionsRequired && n.extensionsRequired.indexOf(t) >= 0) throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported."); return s.loadTexture(e) })) } detectSupport() { return this.isSupported || (this.isSupported = new Promise((function (e) { const t = new Image; t.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", t.onload = t.onerror = function () { e(1 === t.height) } }))), this.isSupported } } class be { constructor(e) { this.parser = e, this.name = fe.EXT_TEXTURE_AVIF, this.isSupported = null } loadTexture(e) { const t = this.name, s = this.parser, n = s.json, r = n.textures[e]; if (!r.extensions || !r.extensions[t]) return null; const o = r.extensions[t], i = n.images[o.source]; let a = s.textureLoader; if (i.uri) { const e = s.options.manager.getHandler(i.uri); null !== e && (a = e) } return this.detectSupport().then((function (r) { if (r) return s.loadTextureImage(e, o.source, a); if (n.extensionsRequired && n.extensionsRequired.indexOf(t) >= 0) throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported."); return s.loadTexture(e) })) } detectSupport() { return this.isSupported || (this.isSupported = new Promise((function (e) { const t = new Image; t.src = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=", t.onload = t.onerror = function () { e(1 === t.height) } }))), this.isSupported } } class Ne { constructor(e) { this.name = fe.EXT_MESHOPT_COMPRESSION, this.parser = e } loadBufferView(e) { const t = this.parser.json, s = t.bufferViews[e]; if (s.extensions && s.extensions[this.name]) { const e = s.extensions[this.name], n = this.parser.getDependency("buffer", e.buffer), r = this.parser.options.meshoptDecoder; if (!r || !r.supported) { if (t.extensionsRequired && t.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files"); return null } return n.then((function (t) { const s = e.byteOffset || 0, n = e.byteLength || 0, o = e.count, i = e.byteStride, a = new Uint8Array(t, s, n); return r.decodeGltfBufferAsync ? r.decodeGltfBufferAsync(o, i, a, e.mode, e.filter).then((function (e) { return e.buffer })) : r.ready.then((function () { const t = new ArrayBuffer(o * i); return r.decodeGltfBuffer(new Uint8Array(t), o, i, a, e.mode, e.filter), t })) })) } return null } } class Oe { constructor(e) { this.name = fe.EXT_MESH_GPU_INSTANCING, this.parser = e } createNodeMesh(e) { const t = this.parser.json, s = t.nodes[e]; if (!s.extensions || !s.extensions[this.name] || void 0 === s.mesh) return null; const o = t.meshes[s.mesh]; for (const e of o.primitives) if (e.mode !== Ke.TRIANGLES && e.mode !== Ke.TRIANGLE_STRIP && e.mode !== Ke.TRIANGLE_FAN && void 0 !== e.mode) return null; const i = s.extensions[this.name].attributes, a = [], c = {}; for (const e in i) a.push(this.parser.getDependency("accessor", i[e]).then((t => (c[e] = t, c[e])))); return a.length < 1 ? null : (a.push(this.parser.createNodeMesh(e)), Promise.all(a).then((e => { const t = e.pop(), s = t.isGroup ? t.children : [t], o = e[0].count, i = []; for (const e of s) { const t = new r, s = new g, a = new n, l = new g(1, 1, 1), u = new T(e.geometry, e.material, o); for (let e = 0; e < o; e++)c.TRANSLATION && s.fromBufferAttribute(c.TRANSLATION, e), c.ROTATION && a.fromBufferAttribute(c.ROTATION, e), c.SCALE && l.fromBufferAttribute(c.SCALE, e), u.setMatrixAt(e, t.compose(s, a, l)); for (const t in c) if ("_COLOR_0" === t) { const e = c[t]; u.instanceColor = new x(e.array, e.itemSize, e.normalized) } else "TRANSLATION" !== t && "ROTATION" !== t && "SCALE" !== t && e.geometry.setAttribute(t, c[t]); R.prototype.copy.call(u, e), this.parser.assignFinalMaterial(u), i.push(u) } return t.isGroup ? (t.clear(), t.add(...i), t) : i[0] }))) } } const Ce = "glTF", Pe = 1313821514, He = 5130562; class Fe { constructor(e) { this.name = fe.KHR_BINARY_GLTF, this.content = null, this.body = null; const t = new DataView(e, 0, 12), s = new TextDecoder; if (this.header = { magic: s.decode(new Uint8Array(e.slice(0, 4))), version: t.getUint32(4, !0), length: t.getUint32(8, !0) }, this.header.magic !== Ce) throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header."); if (this.header.version < 2) throw new Error("THREE.GLTFLoader: Legacy binary file detected."); const n = this.header.length - 12, r = new DataView(e, 12); let o = 0; for (; o < n;) { const t = r.getUint32(o, !0); o += 4; const n = r.getUint32(o, !0); if (o += 4, n === Pe) { const n = new Uint8Array(e, 12 + o, t); this.content = s.decode(n) } else if (n === He) { const s = 12 + o; this.body = e.slice(s, s + t) } o += t } if (null === this.content) throw new Error("THREE.GLTFLoader: JSON content not found.") } } class ke { constructor(e, t) { if (!t) throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided."); this.name = fe.KHR_DRACO_MESH_COMPRESSION, this.json = e, this.dracoLoader = t, this.dracoLoader.preload() } decodePrimitive(e, t) { const s = this.json, n = this.dracoLoader, r = e.extensions[this.name].bufferView, o = e.extensions[this.name].attributes, i = {}, a = {}, c = {}; for (const e in o) { const t = Ye[e] || e.toLowerCase(); i[t] = o[e] } for (const t in e.attributes) { const n = Ye[t] || t.toLowerCase(); if (void 0 !== o[t]) { const r = s.accessors[e.attributes[t]], o = Xe[r.componentType]; c[n] = o.name, a[n] = !0 === r.normalized } } return t.getDependency("bufferView", r).then((function (e) { return new Promise((function (t, s) { n.decodeDracoFile(e, (function (e) { for (const t in e.attributes) { const s = e.attributes[t], n = a[t]; void 0 !== n && (s.normalized = n) } t(e) }), i, c, l, s) })) })) } } class De { constructor() { this.name = fe.KHR_TEXTURE_TRANSFORM } extendTexture(e, t) { return void 0 !== t.texCoord && t.texCoord !== e.channel || void 0 !== t.offset || void 0 !== t.rotation || void 0 !== t.scale ? (e = e.clone(), void 0 !== t.texCoord && (e.channel = t.texCoord), void 0 !== t.offset && e.offset.fromArray(t.offset), void 0 !== t.rotation && (e.rotation = t.rotation), void 0 !== t.scale && e.repeat.fromArray(t.scale), e.needsUpdate = !0, e) : e } } class Ue { constructor() { this.name = fe.KHR_MESH_QUANTIZATION } } class Be extends he { constructor(e, t, s, n) { super(e, t, s, n) } copySampleValue_(e) { const t = this.resultBuffer, s = this.sampleValues, n = this.valueSize, r = e * n * 3 + n; for (let e = 0; e !== n; e++)t[e] = s[r + e]; return t } interpolate_(e, t, s, n) { const r = this.resultBuffer, o = this.sampleValues, i = this.valueSize, a = 2 * i, c = 3 * i, l = n - t, u = (s - t) / l, h = u * u, d = h * u, m = e * c, p = m - c, f = -2 * d + 3 * h, A = d - h, g = 1 - f, T = A - h + u; for (let e = 0; e !== i; e++) { const t = o[p + e + i], s = o[p + e + a] * l, n = o[m + e + i], c = o[m + e] * l; r[e] = g * t + T * s + f * n + A * c } return r } } const Ge = new n; class je extends Be { interpolate_(e, t, s, n) { const r = super.interpolate_(e, t, s, n); return Ge.fromArray(r).normalize().toArray(r), r } } const Ke = { FLOAT: 5126, FLOAT_MAT3: 35675, FLOAT_MAT4: 35676, FLOAT_VEC2: 35664, FLOAT_VEC3: 35665, FLOAT_VEC4: 35666, LINEAR: 9729, REPEAT: 10497, SAMPLER_2D: 35678, POINTS: 0, LINES: 1, LINE_LOOP: 2, LINE_STRIP: 3, TRIANGLES: 4, TRIANGLE_STRIP: 5, TRIANGLE_FAN: 6, UNSIGNED_BYTE: 5121, UNSIGNED_SHORT: 5123 }, Xe = { 5120: Int8Array, 5121: Uint8Array, 5122: Int16Array, 5123: Uint16Array, 5125: Uint32Array, 5126: Float32Array }, Ve = { 9728: Z, 9729: S, 9984: J, 9985: $, 9986: ee, 9987: L }, qe = { 33071: te, 33648: se, 10497: I }, ze = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 }, Ye = { POSITION: "position", NORMAL: "normal", TANGENT: "tangent", TEXCOORD_0: "uv", TEXCOORD_1: "uv1", TEXCOORD_2: "uv2", TEXCOORD_3: "uv3", COLOR_0: "color", WEIGHTS_0: "skinWeight", JOINTS_0: "skinIndex" }, We = { scale: "scale", translation: "position", rotation: "quaternion", weights: "morphTargetInfluences" }, Qe = { CUBICSPLINE: void 0, LINEAR: W, STEP: ne }, Ze = "OPAQUE", Je = "MASK", $e = "BLEND"; function et(e, t, s) { for (const n in s.extensions) void 0 === e[n] && (t.userData.gltfExtensions = t.userData.gltfExtensions || {}, t.userData.gltfExtensions[n] = s.extensions[n]) } function tt(e, t) { void 0 !== t.extras && ("object" == typeof t.extras ? Object.assign(e.userData, t.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + t.extras)) } function st(e, t) { if (e.updateMorphTargets(), void 0 !== t.weights) for (let s = 0, n = t.weights.length; s < n; s++)e.morphTargetInfluences[s] = t.weights[s]; if (t.extras && Array.isArray(t.extras.targetNames)) { const s = t.extras.targetNames; if (e.morphTargetInfluences.length === s.length) { e.morphTargetDictionary = {}; for (let t = 0, n = s.length; t < n; t++)e.morphTargetDictionary[s[t]] = t } else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.") } } function nt(e) { let t; const s = e.extensions && e.extensions[fe.KHR_DRACO_MESH_COMPRESSION]; if (t = s ? "draco:" + s.bufferView + ":" + s.indices + ":" + rt(s.attributes) : e.indices + ":" + rt(e.attributes) + ":" + e.mode, void 0 !== e.targets) for (let s = 0, n = e.targets.length; s < n; s++)t += ":" + rt(e.targets[s]); return t } function rt(e) { let t = ""; const s = Object.keys(e).sort(); for (let n = 0, r = s.length; n < r; n++)t += s[n] + ":" + e[s[n]] + ";"; return t } function ot(e) { switch (e) { case Int8Array: return 1 / 127; case Uint8Array: return 1 / 255; case Int16Array: return 1 / 32767; case Uint16Array: return 1 / 65535; default: throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.") } } const it = new r; class at { constructor(e = {}, t = {}) { this.json = e, this.extensions = {}, this.plugins = {}, this.options = t, this.cache = new pe, this.associations = new Map, this.primitiveCache = {}, this.nodeCache = {}, this.meshCache = { refs: {}, uses: {} }, this.cameraCache = { refs: {}, uses: {} }, this.lightCache = { refs: {}, uses: {} }, this.sourceCache = {}, this.textureCache = {}, this.nodeNamesUsed = {}; let s = !1, n = !1, r = -1; "undefined" != typeof navigator && (s = !0 === /^((?!chrome|android).)*safari/i.test(navigator.userAgent), n = navigator.userAgent.indexOf("Firefox") > -1, r = n ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1), "undefined" == typeof createImageBitmap || s || n && r < 98 ? this.textureLoader = new E(this.options.manager) : this.textureLoader = new _(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new a(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), "use-credentials" === this.options.crossOrigin && this.fileLoader.setWithCredentials(!0) } setExtensions(e) { this.extensions = e } setPlugins(e) { this.plugins = e } parse(e, t) { const s = this, n = this.json, r = this.extensions; this.cache.removeAll(), this.nodeCache = {}, this._invokeAll((function (e) { return e._markDefs && e._markDefs() })), Promise.all(this._invokeAll((function (e) { return e.beforeRoot && e.beforeRoot() }))).then((function () { return Promise.all([s.getDependencies("scene"), s.getDependencies("animation"), s.getDependencies("camera")]) })).then((function (t) { const o = { scene: t[0][n.scene || 0], scenes: t[0], animations: t[1], cameras: t[2], asset: n.asset, parser: s, userData: {} }; return et(r, o, n), tt(o, n), Promise.all(s._invokeAll((function (e) { return e.afterRoot && e.afterRoot(o) }))).then((function () { e(o) })) })).catch(t) } _markDefs() { const e = this.json.nodes || [], t = this.json.skins || [], s = this.json.meshes || []; for (let s = 0, n = t.length; s < n; s++) { const n = t[s].joints; for (let t = 0, s = n.length; t < s; t++)e[n[t]].isBone = !0 } for (let t = 0, n = e.length; t < n; t++) { const n = e[t]; void 0 !== n.mesh && (this._addNodeRef(this.meshCache, n.mesh), void 0 !== n.skin && (s[n.mesh].isSkinnedMesh = !0)), void 0 !== n.camera && this._addNodeRef(this.cameraCache, n.camera) } } _addNodeRef(e, t) { void 0 !== t && (void 0 === e.refs[t] && (e.refs[t] = e.uses[t] = 0), e.refs[t]++) } _getNodeRef(e, t, s) { if (e.refs[t] <= 1) return s; const n = s.clone(), r = (e, t) => { const s = this.associations.get(e); null != s && this.associations.set(t, s); for (const [s, n] of e.children.entries()) r(n, t.children[s]) }; return r(s, n), n.name += "_instance_" + e.uses[t]++, n } _invokeOne(e) { const t = Object.values(this.plugins); t.push(this); for (let s = 0; s < t.length; s++) { const n = e(t[s]); if (n) return n } return null } _invokeAll(e) { const t = Object.values(this.plugins); t.unshift(this); const s = []; for (let n = 0; n < t.length; n++) { const r = e(t[n]); r && s.push(r) } return s } getDependency(e, t) { const s = e + ":" + t; let n = this.cache.get(s); if (!n) { switch (e) { case "scene": n = this.loadScene(t); break; case "node": n = this._invokeOne((function (e) { return e.loadNode && e.loadNode(t) })); break; case "mesh": n = this._invokeOne((function (e) { return e.loadMesh && e.loadMesh(t) })); break; case "accessor": n = this.loadAccessor(t); break; case "bufferView": n = this._invokeOne((function (e) { return e.loadBufferView && e.loadBufferView(t) })); break; case "buffer": n = this.loadBuffer(t); break; case "material": n = this._invokeOne((function (e) { return e.loadMaterial && e.loadMaterial(t) })); break; case "texture": n = this._invokeOne((function (e) { return e.loadTexture && e.loadTexture(t) })); break; case "skin": n = this.loadSkin(t); break; case "animation": n = this._invokeOne((function (e) { return e.loadAnimation && e.loadAnimation(t) })); break; case "camera": n = this.loadCamera(t); break; default: if (n = this._invokeOne((function (s) { return s != this && s.getDependency && s.getDependency(e, t) })), !n) throw new Error("Unknown type: " + e) }this.cache.add(s, n) } return n } getDependencies(e) { let t = this.cache.get(e); if (!t) { const s = this, n = this.json[e + ("mesh" === e ? "es" : "s")] || []; t = Promise.all(n.map((function (t, n) { return s.getDependency(e, n) }))), this.cache.add(e, t) } return t } loadBuffer(e) { const t = this.json.buffers[e], s = this.fileLoader; if (t.type && "arraybuffer" !== t.type) throw new Error("THREE.GLTFLoader: " + t.type + " buffer type is not supported."); if (void 0 === t.uri && 0 === e) return Promise.resolve(this.extensions[fe.KHR_BINARY_GLTF].body); const n = this.options; return new Promise((function (e, r) { s.load(i.resolveURL(t.uri, n.path), e, void 0, (function () { r(new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".')) })) })) } loadBufferView(e) { const t = this.json.bufferViews[e]; return this.getDependency("buffer", t.buffer).then((function (e) { const s = t.byteLength || 0, n = t.byteOffset || 0; return e.slice(n, n + s) })) } loadAccessor(e) { const t = this, s = this.json, n = this.json.accessors[e]; if (void 0 === n.bufferView && void 0 === n.sparse) { const e = ze[n.type], t = Xe[n.componentType], s = !0 === n.normalized, r = new t(n.count * e); return Promise.resolve(new v(r, e, s)) } const r = []; return void 0 !== n.bufferView ? r.push(this.getDependency("bufferView", n.bufferView)) : r.push(null), void 0 !== n.sparse && (r.push(this.getDependency("bufferView", n.sparse.indices.bufferView)), r.push(this.getDependency("bufferView", n.sparse.values.bufferView))), Promise.all(r).then((function (e) { const r = e[0], o = ze[n.type], i = Xe[n.componentType], a = i.BYTES_PER_ELEMENT, c = a * o, l = n.byteOffset || 0, u = void 0 !== n.bufferView ? s.bufferViews[n.bufferView].byteStride : void 0, h = !0 === n.normalized; let d, m; if (u && u !== c) { const e = Math.floor(l / u), s = "InterleavedBuffer:" + n.bufferView + ":" + n.componentType + ":" + e + ":" + n.count; let c = t.cache.get(s); c || (d = new i(r, e * u, n.count * u / a), c = new w(d, u / a), t.cache.add(s, c)), m = new y(c, o, l % u / a, h) } else d = null === r ? new i(n.count * o) : new i(r, l, n.count * o), m = new v(d, o, h); if (void 0 !== n.sparse) { const t = ze.SCALAR, s = Xe[n.sparse.indices.componentType], a = n.sparse.indices.byteOffset || 0, c = n.sparse.values.byteOffset || 0, l = new s(e[1], a, n.sparse.count * t), u = new i(e[2], c, n.sparse.count * o); null !== r && (m = new v(m.array.slice(), m.itemSize, m.normalized)); for (let e = 0, t = l.length; e < t; e++) { const t = l[e]; if (m.setX(t, u[e * o]), o >= 2 && m.setY(t, u[e * o + 1]), o >= 3 && m.setZ(t, u[e * o + 2]), o >= 4 && m.setW(t, u[e * o + 3]), o >= 5) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.") } } return m })) } loadTexture(e) { const t = this.json, s = this.options, n = t.textures[e].source, r = t.images[n]; let o = this.textureLoader; if (r.uri) { const e = s.manager.getHandler(r.uri); null !== e && (o = e) } return this.loadTextureImage(e, n, o) } loadTextureImage(e, t, s) { const n = this, r = this.json, o = r.textures[e], i = r.images[t], a = (i.uri || i.bufferView) + ":" + o.sampler; if (this.textureCache[a]) return this.textureCache[a]; const c = this.loadImageSource(t, s).then((function (t) { t.flipY = !1, t.name = o.name || i.name || "", "" === t.name && "string" == typeof i.uri && !1 === i.uri.startsWith("data:image/") && (t.name = i.uri); const s = (r.samplers || {})[o.sampler] || {}; return t.magFilter = Ve[s.magFilter] || S, t.minFilter = Ve[s.minFilter] || L, t.wrapS = qe[s.wrapS] || I, t.wrapT = qe[s.wrapT] || I, n.associations.set(t, { textures: e }), t })).catch((function () { return null })); return this.textureCache[a] = c, c } loadImageSource(e, t) { const s = this, n = this.json, r = this.options; if (void 0 !== this.sourceCache[e]) return this.sourceCache[e].then((e => e.clone())); const o = n.images[e], a = self.URL || self.webkitURL; let c = o.uri || "", l = !1; if (void 0 !== o.bufferView) c = s.getDependency("bufferView", o.bufferView).then((function (e) { l = !0; const t = new Blob([e], { type: o.mimeType }); return c = a.createObjectURL(t), c })); else if (void 0 === o.uri) throw new Error("THREE.GLTFLoader: Image " + e + " is missing URI and bufferView"); const u = Promise.resolve(c).then((function (e) { return new Promise((function (s, n) { let o = s; !0 === t.isImageBitmapLoader && (o = function (e) { const t = new oe(e); t.needsUpdate = !0, s(t) }), t.load(i.resolveURL(e, r.path), o, void 0, n) })) })).then((function (e) { var t; return !0 === l && a.revokeObjectURL(c), e.userData.mimeType = o.mimeType || ((t = o.uri).search(/\.jpe?g($|\?)/i) > 0 || 0 === t.search(/^data\:image\/jpeg/) ? "image/jpeg" : t.search(/\.webp($|\?)/i) > 0 || 0 === t.search(/^data\:image\/webp/) ? "image/webp" : "image/png"), e })).catch((function (e) { throw console.error("THREE.GLTFLoader: Couldn't load texture", c), e })); return this.sourceCache[e] = u, u } assignTexture(e, t, s, n) { const r = this; return this.getDependency("texture", s.index).then((function (o) { if (!o) return null; if (void 0 !== s.texCoord && s.texCoord > 0 && ((o = o.clone()).channel = s.texCoord), r.extensions[fe.KHR_TEXTURE_TRANSFORM]) { const e = void 0 !== s.extensions ? s.extensions[fe.KHR_TEXTURE_TRANSFORM] : void 0; if (e) { const t = r.associations.get(o); o = r.extensions[fe.KHR_TEXTURE_TRANSFORM].extendTexture(o, e), r.associations.set(o, t) } } return void 0 !== n && (o.colorSpace = n), e[t] = o, o })) } assignFinalMaterial(e) { const t = e.geometry; let s = e.material; const n = void 0 === t.attributes.tangent, r = void 0 !== t.attributes.color, o = void 0 === t.attributes.normal; if (e.isPoints) { const e = "PointsMaterial:" + s.uuid; let t = this.cache.get(e); t || (t = new M, b.prototype.copy.call(t, s), t.color.copy(s.color), t.map = s.map, t.sizeAttenuation = !1, this.cache.add(e, t)), s = t } else if (e.isLine) { const e = "LineBasicMaterial:" + s.uuid; let t = this.cache.get(e); t || (t = new N, b.prototype.copy.call(t, s), t.color.copy(s.color), t.map = s.map, this.cache.add(e, t)), s = t } if (n || r || o) { let e = "ClonedMaterial:" + s.uuid + ":"; n && (e += "derivative-tangents:"), r && (e += "vertex-colors:"), o && (e += "flat-shading:"); let t = this.cache.get(e); t || (t = s.clone(), r && (t.vertexColors = !0), o && (t.flatShading = !0), n && (t.normalScale && (t.normalScale.y *= -1), t.clearcoatNormalScale && (t.clearcoatNormalScale.y *= -1)), this.cache.add(e, t), this.associations.set(t, this.associations.get(s))), s = t } e.material = s } getMaterialType() { return O } loadMaterial(e) { const t = this, s = this.json, n = this.extensions, r = s.materials[e]; let o; const i = {}, a = []; if ((r.extensions || {})[fe.KHR_MATERIALS_UNLIT]) { const e = n[fe.KHR_MATERIALS_UNLIT]; o = e.getMaterialType(), a.push(e.extendParams(i, r, t)) } else { const s = r.pbrMetallicRoughness || {}; if (i.color = new c(1, 1, 1), i.opacity = 1, Array.isArray(s.baseColorFactor)) { const e = s.baseColorFactor; i.color.setRGB(e[0], e[1], e[2], l), i.opacity = e[3] } void 0 !== s.baseColorTexture && a.push(t.assignTexture(i, "map", s.baseColorTexture, p)), i.metalness = void 0 !== s.metallicFactor ? s.metallicFactor : 1, i.roughness = void 0 !== s.roughnessFactor ? s.roughnessFactor : 1, void 0 !== s.metallicRoughnessTexture && (a.push(t.assignTexture(i, "metalnessMap", s.metallicRoughnessTexture)), a.push(t.assignTexture(i, "roughnessMap", s.metallicRoughnessTexture))), o = this._invokeOne((function (t) { return t.getMaterialType && t.getMaterialType(e) })), a.push(Promise.all(this._invokeAll((function (t) { return t.extendMaterialParams && t.extendMaterialParams(e, i) })))) } !0 === r.doubleSided && (i.side = C); const u = r.alphaMode || Ze; if (u === $e ? (i.transparent = !0, i.depthWrite = !1) : (i.transparent = !1, u === Je && (i.alphaTest = void 0 !== r.alphaCutoff ? r.alphaCutoff : .5)), void 0 !== r.normalTexture && o !== m && (a.push(t.assignTexture(i, "normalMap", r.normalTexture)), i.normalScale = new A(1, 1), void 0 !== r.normalTexture.scale)) { const e = r.normalTexture.scale; i.normalScale.set(e, e) } if (void 0 !== r.occlusionTexture && o !== m && (a.push(t.assignTexture(i, "aoMap", r.occlusionTexture)), void 0 !== r.occlusionTexture.strength && (i.aoMapIntensity = r.occlusionTexture.strength)), void 0 !== r.emissiveFactor && o !== m) { const e = r.emissiveFactor; i.emissive = (new c).setRGB(e[0], e[1], e[2], l) } return void 0 !== r.emissiveTexture && o !== m && a.push(t.assignTexture(i, "emissiveMap", r.emissiveTexture, p)), Promise.all(a).then((function () { const s = new o(i); return r.name && (s.name = r.name), tt(s, r), t.associations.set(s, { materials: e }), r.extensions && et(n, s, r), s })) } createUniqueName(e) { const t = P.sanitizeNodeName(e || ""); return t in this.nodeNamesUsed ? t + "_" + ++this.nodeNamesUsed[t] : (this.nodeNamesUsed[t] = 0, t) } loadGeometries(e) { const t = this, s = this.extensions, n = this.primitiveCache; function r(e) { return s[fe.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(e, t).then((function (s) { return ct(s, e, t) })) } const o = []; for (let s = 0, i = e.length; s < i; s++) { const i = e[s], a = nt(i), c = n[a]; if (c) o.push(c.promise); else { let e; e = i.extensions && i.extensions[fe.KHR_DRACO_MESH_COMPRESSION] ? r(i) : ct(new H, i, t), n[a] = { primitive: i, promise: e }, o.push(e) } } return Promise.all(o) } loadMesh(e) { const n = this, r = this.json, o = this.extensions, i = r.meshes[e], a = i.primitives, c = []; for (let e = 0, t = a.length; e < t; e++) { const t = void 0 === a[e].material ? (void 0 === (l = this.cache).DefaultMaterial && (l.DefaultMaterial = new O({ color: 16777215, emissive: 0, metalness: 1, roughness: 1, transparent: !1, depthTest: !0, side: re })), l.DefaultMaterial) : this.getDependency("material", a[e].material); c.push(t) } var l; return c.push(n.loadGeometries(a)), Promise.all(c).then((function (r) { const c = r.slice(0, r.length - 1), l = r[r.length - 1], u = []; for (let r = 0, h = l.length; r < h; r++) { const h = l[r], d = a[r]; let m; const p = c[r]; if (d.mode === Ke.TRIANGLES || d.mode === Ke.TRIANGLE_STRIP || d.mode === Ke.TRIANGLE_FAN || void 0 === d.mode) m = !0 === i.isSkinnedMesh ? new F(h, p) : new k(h, p), !0 === m.isSkinnedMesh && m.normalizeSkinWeights(), d.mode === Ke.TRIANGLE_STRIP ? m.geometry = de(m.geometry, s) : d.mode === Ke.TRIANGLE_FAN && (m.geometry = de(m.geometry, t)); else if (d.mode === Ke.LINES) m = new D(h, p); else if (d.mode === Ke.LINE_STRIP) m = new U(h, p); else if (d.mode === Ke.LINE_LOOP) m = new B(h, p); else { if (d.mode !== Ke.POINTS) throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + d.mode); m = new G(h, p) } Object.keys(m.geometry.morphAttributes).length > 0 && st(m, i), m.name = n.createUniqueName(i.name || "mesh_" + e), tt(m, i), d.extensions && et(o, m, d), n.assignFinalMaterial(m), u.push(m) } for (let t = 0, s = u.length; t < s; t++)n.associations.set(u[t], { meshes: e, primitives: t }); if (1 === u.length) return i.extensions && et(o, u[0], i), u[0]; const h = new j; i.extensions && et(o, h, i), n.associations.set(h, { meshes: e }); for (let e = 0, t = u.length; e < t; e++)h.add(u[e]); return h })) } loadCamera(e) { let t; const s = this.json.cameras[e], n = s[s.type]; if (n) return "perspective" === s.type ? t = new K(X.radToDeg(n.yfov), n.aspectRatio || 1, n.znear || 1, n.zfar || 2e6) : "orthographic" === s.type && (t = new V(-n.xmag, n.xmag, n.ymag, -n.ymag, n.znear, n.zfar)), s.name && (t.name = this.createUniqueName(s.name)), tt(t, s), Promise.resolve(t); console.warn("THREE.GLTFLoader: Missing camera parameters.") } loadSkin(e) { const t = this.json.skins[e], s = []; for (let e = 0, n = t.joints.length; e < n; e++)s.push(this._loadNodeShallow(t.joints[e])); return void 0 !== t.inverseBindMatrices ? s.push(this.getDependency("accessor", t.inverseBindMatrices)) : s.push(null), Promise.all(s).then((function (e) { const s = e.pop(), n = e, o = [], i = []; for (let e = 0, a = n.length; e < a; e++) { const a = n[e]; if (a) { o.push(a); const t = new r; null !== s && t.fromArray(s.array, 16 * e), i.push(t) } else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', t.joints[e]) } return new q(o, i) })) } loadAnimation(e) { const t = this.json, s = this, n = t.animations[e], r = n.name ? n.name : "animation_" + e, o = [], i = [], a = [], c = [], l = []; for (let e = 0, t = n.channels.length; e < t; e++) { const t = n.channels[e], s = n.samplers[t.sampler], r = t.target, u = r.node, h = void 0 !== n.parameters ? n.parameters[s.input] : s.input, d = void 0 !== n.parameters ? n.parameters[s.output] : s.output; void 0 !== r.node && (o.push(this.getDependency("node", u)), i.push(this.getDependency("accessor", h)), a.push(this.getDependency("accessor", d)), c.push(s), l.push(r)) } return Promise.all([Promise.all(o), Promise.all(i), Promise.all(a), Promise.all(c), Promise.all(l)]).then((function (e) { const t = e[0], n = e[1], o = e[2], i = e[3], a = e[4], c = []; for (let e = 0, r = t.length; e < r; e++) { const r = t[e], l = n[e], u = o[e], h = i[e], d = a[e]; if (void 0 === r) continue; r.updateMatrix && r.updateMatrix(); const m = s._createAnimationTracks(r, l, u, h, d); if (m) for (let e = 0; e < m.length; e++)c.push(m[e]) } return new z(r, void 0, c) })) } createNodeMesh(e) { const t = this.json, s = this, n = t.nodes[e]; return void 0 === n.mesh ? null : s.getDependency("mesh", n.mesh).then((function (e) { const t = s._getNodeRef(s.meshCache, n.mesh, e); return void 0 !== n.weights && t.traverse((function (e) { if (e.isMesh) for (let t = 0, s = n.weights.length; t < s; t++)e.morphTargetInfluences[t] = n.weights[t] })), t })) } loadNode(e) { const t = this, s = this.json.nodes[e], n = t._loadNodeShallow(e), r = [], o = s.children || []; for (let e = 0, s = o.length; e < s; e++)r.push(t.getDependency("node", o[e])); const i = void 0 === s.skin ? Promise.resolve(null) : t.getDependency("skin", s.skin); return Promise.all([n, Promise.all(r), i]).then((function (e) { const t = e[0], s = e[1], n = e[2]; null !== n && t.traverse((function (e) { e.isSkinnedMesh && e.bind(n, it) })); for (let e = 0, n = s.length; e < n; e++)t.add(s[e]); return t })) } _loadNodeShallow(e) { const t = this.json, s = this.extensions, n = this; if (void 0 !== this.nodeCache[e]) return this.nodeCache[e]; const o = t.nodes[e], i = o.name ? n.createUniqueName(o.name) : "", a = [], c = n._invokeOne((function (t) { return t.createNodeMesh && t.createNodeMesh(e) })); return c && a.push(c), void 0 !== o.camera && a.push(n.getDependency("camera", o.camera).then((function (e) { return n._getNodeRef(n.cameraCache, o.camera, e) }))), n._invokeAll((function (t) { return t.createNodeAttachment && t.createNodeAttachment(e) })).forEach((function (e) { a.push(e) })), this.nodeCache[e] = Promise.all(a).then((function (t) { let a; if (a = !0 === o.isBone ? new Y : t.length > 1 ? new j : 1 === t.length ? t[0] : new R, a !== t[0]) for (let e = 0, s = t.length; e < s; e++)a.add(t[e]); if (o.name && (a.userData.name = o.name, a.name = i), tt(a, o), o.extensions && et(s, a, o), void 0 !== o.matrix) { const e = new r; e.fromArray(o.matrix), a.applyMatrix4(e) } else void 0 !== o.translation && a.position.fromArray(o.translation), void 0 !== o.rotation && a.quaternion.fromArray(o.rotation), void 0 !== o.scale && a.scale.fromArray(o.scale); return n.associations.has(a) || n.associations.set(a, {}), n.associations.get(a).nodes = e, a })), this.nodeCache[e] } loadScene(e) { const t = this.extensions, s = this.json.scenes[e], n = this, r = new j; s.name && (r.name = n.createUniqueName(s.name)), tt(r, s), s.extensions && et(t, r, s); const o = s.nodes || [], i = []; for (let e = 0, t = o.length; e < t; e++)i.push(n.getDependency("node", o[e])); return Promise.all(i).then((function (e) { for (let t = 0, s = e.length; t < s; t++)r.add(e[t]); return n.associations = (e => { const t = new Map; for (const [e, s] of n.associations) (e instanceof b || e instanceof oe) && t.set(e, s); return e.traverse((e => { const s = n.associations.get(e); null != s && t.set(e, s) })), t })(r), r })) } _createAnimationTracks(e, t, s, n, r) { const o = [], i = e.name ? e.name : e.uuid, a = []; let c; switch (We[r.path] === We.weights ? e.traverse((function (e) { e.morphTargetInfluences && a.push(e.name ? e.name : e.uuid) })) : a.push(i), We[r.path]) { case We.weights: c = ae; break; case We.rotation: c = ce; break; case We.position: case We.scale: c = ie; break; default: if (1 === s.itemSize) c = ae; else c = ie }const l = void 0 !== n.interpolation ? Qe[n.interpolation] : W, u = this._getArrayFromAccessor(s); for (let e = 0, s = a.length; e < s; e++) { const s = new c(a[e] + "." + We[r.path], t.array, u, l); "CUBICSPLINE" === n.interpolation && this._createCubicSplineTrackInterpolant(s), o.push(s) } return o } _getArrayFromAccessor(e) { let t = e.array; if (e.normalized) { const e = ot(t.constructor), s = new Float32Array(t.length); for (let n = 0, r = t.length; n < r; n++)s[n] = t[n] * e; t = s } return t } _createCubicSplineTrackInterpolant(e) { e.createInterpolant = function (e) { return new (this instanceof ce ? je : Be)(this.times, this.values, this.getValueSize() / 3, e) }, e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0 } } function ct(e, t, s) { const n = t.attributes, r = []; function o(t, n) { return s.getDependency("accessor", t).then((function (t) { e.setAttribute(n, t) })) } for (const t in n) { const s = Ye[t] || t.toLowerCase(); s in e.attributes || r.push(o(n[t], s)) } if (void 0 !== t.indices && !e.index) { const n = s.getDependency("accessor", t.indices).then((function (t) { e.setIndex(t) })); r.push(n) } return Q.workingColorSpace !== l && "COLOR_0" in n && console.warn(`THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${Q.workingColorSpace}" not supported.`), tt(e, t), function (e, t, s) { const n = t.attributes, r = new le; if (void 0 === n.POSITION) return; { const e = s.json.accessors[n.POSITION], t = e.min, o = e.max; if (void 0 === t || void 0 === o) return void console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION."); if (r.set(new g(t[0], t[1], t[2]), new g(o[0], o[1], o[2])), e.normalized) { const t = ot(Xe[e.componentType]); r.min.multiplyScalar(t), r.max.multiplyScalar(t) } } const o = t.targets; if (void 0 !== o) { const e = new g, t = new g; for (let n = 0, r = o.length; n < r; n++) { const r = o[n]; if (void 0 !== r.POSITION) { const n = s.json.accessors[r.POSITION], o = n.min, i = n.max; if (void 0 !== o && void 0 !== i) { if (t.setX(Math.max(Math.abs(o[0]), Math.abs(i[0]))), t.setY(Math.max(Math.abs(o[1]), Math.abs(i[1]))), t.setZ(Math.max(Math.abs(o[2]), Math.abs(i[2]))), n.normalized) { const e = ot(Xe[n.componentType]); t.multiplyScalar(e) } e.max(t) } else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.") } } r.expandByVector(e) } e.boundingBox = r; const i = new ue; r.getCenter(i.center), i.radius = r.min.distanceTo(r.max) / 2, e.boundingSphere = i }(e, t, s), Promise.all(r).then((function () { return void 0 !== t.targets ? function (e, t, s) { let n = !1, r = !1, o = !1; for (let e = 0, s = t.length; e < s; e++) { const s = t[e]; if (void 0 !== s.POSITION && (n = !0), void 0 !== s.NORMAL && (r = !0), void 0 !== s.COLOR_0 && (o = !0), n && r && o) break } if (!n && !r && !o) return Promise.resolve(e); const i = [], a = [], c = []; for (let l = 0, u = t.length; l < u; l++) { const u = t[l]; if (n) { const t = void 0 !== u.POSITION ? s.getDependency("accessor", u.POSITION) : e.attributes.position; i.push(t) } if (r) { const t = void 0 !== u.NORMAL ? s.getDependency("accessor", u.NORMAL) : e.attributes.normal; a.push(t) } if (o) { const t = void 0 !== u.COLOR_0 ? s.getDependency("accessor", u.COLOR_0) : e.attributes.color; c.push(t) } } return Promise.all([Promise.all(i), Promise.all(a), Promise.all(c)]).then((function (t) { const s = t[0], i = t[1], a = t[2]; return n && (e.morphAttributes.position = s), r && (e.morphAttributes.normal = i), o && (e.morphAttributes.color = a), e.morphTargetsRelative = !0, e })) }(e, t.targets, s) : e })) } export { me as GLTFLoader }; export default null;
//# sourceMappingURL=/sm/46beee312364134aad236ed2a2c55fec1360982e002276661b7f2bfb2262ba38.map